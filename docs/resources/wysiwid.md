

# What You See Is What It Does: A Structural Pattern for Legible Software

Eagon Meng

Massachusetts Institute of Technology  
Cambridge, USA  
eagon@mit.edu

Daniel Jackson

Massachusetts Institute of Technology  
Cambridge, USA  
dnj@mit.edu

## Abstract

The opportunities offered by LLM coders (and their current limitations) demand a reevaluation of how software is structured. Software today is often “illegible”—lacking a direct correspondence between code and observed behavior—and insufficiently modular, leading to a failure of three key requirements of robust coding: incrementality (the ability to deliver small increments by making localized changes), integrity (avoiding breaking prior increments) and transparency (making clear what has changed at build time, and what actions have happened at runtime).

A new structural pattern offers improved legibility and modularity. Its elements are concepts and synchronizations: fully independent services and event-based rules that mediate between them. A domain-specific language for synchronizations allows behavioral features to be expressed in a granular and declarative way (and thus readily generated by an LLM). A case study of the RealWorld benchmark is used to illustrate and evaluate the approach.

**CCS Concepts:** • Software and its engineering → event-based architectures; Cooperating communicating processes; Abstraction, modeling and modularity; Organizing principles for web applications; Runtime environments; Source code generation; Specification languages; Orchestration languages.

**Keywords:** Programming, software engineering, large language models, artificial intelligence, modularity, concept design, mediators

## ACM Reference Format:

Eagon Meng and Daniel Jackson. 2025. What You See Is What It Does: A Structural Pattern for Legible Software. In *Proceedings of the 2025 ACM SIGPLAN International Symposium on New Ideas, New Paradigms, and Reflections on Programming and Software (Onward! '25)*, October 12–18, 2025, Singapore, Singapore. ACM, New York, NY, USA, 16 pages. <https://doi.org/10.1145/3759429.3762628>

![Creative Commons Attribution-NonCommercial 4.0 International License logo (CC BY NC)](fa6c61be003dfbb4ca5587e48a71de94_img.jpg)

Creative Commons Attribution-NonCommercial 4.0 International License logo (CC BY NC)

This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.

Onward! '25, Singapore, Singapore

© 2025 Copyright held by the owner/author(s).

ACM ISBN 979-8-4007-2151-9/25/10

<https://doi.org/10.1145/3759429.3762628>

## 1 Introduction

Reactions to the growing use of large language models (LLMs) in programming have focused on their promise to automate coding tasks and eliminate drudgery. Less attention has been paid to the respects in which LLMs have exposed deep flaws in the practice of software development, and how a reevaluation might be needed to capitalize on the benefits of LLMs and mitigate their failings. This paper suggests that such a reevaluation might improve the experience of programming not only for LLM coders but for human coders alike.

Most obviously, LLMs overturn a central premise of agile development—that developers should focus on code and that non-code artifacts are of suspect value. Specifications are back, even if they are now called “prompts.”

Less obviously, modularity is ripe for a return. The extraordinary human capacity to tolerate complexity, even when self-inflicted, allows projects to erode (or never clearly define) module boundaries. A lack of investment in structure that eventually exacts a heavy cost is often justified as “technical debt.” When well-defined modules do exist, they may correspond only weakly to the functionality (that is, the observable behavior), so that the code lacks “legibility,” and mapping desired changes in behavior to modifications of code becomes needlessly difficult.

When an LLM is used to add code to an existing repository, it can be hard to control which modules are modified, and to ensure that existing functionality is not broken. A benchmark [23] that measures coding performance on realistic tasks (drawn from a collection of about 2,300 GitHub issues) ranks LLMs by the proportion of coding challenges they can resolve. But a careful study of the benchmark results [2] found that about a third of the resolved issues contained the solution code in the description of the issue itself; another third were deemed correct (because they passed test cases) despite being wrong; and more than 90% had solutions available online before the training cutoff for the evaluated LLMs. When these flaws were taken into account, the success rate fell precipitously.

Programmers complain that LLM coding assistants recommend patches that often break previously generated functionality [24], and “whole app” builders seem often to hit a brick wall, incapable of extending functionality beyond certain (undefined) limits. If LLMs are not able to work *incrementally*, growing a system’s functionality with new features

while preserving the *integrity* of existing ones, their role will be limited.

This paper presents a structural pattern designed to address these issues. Its key elements are *concepts*—independent services with well-defined purposes—and *synchronizations*—granular event-based rules that act as mediators between concepts, orchestrating data and control flow without introducing dependencies between them.

Improved *legibility* comes from the direct correspondence between concepts and coherent units of user-facing functionality, and between synchronizations and (often application-specific) behavioral rules. *Integrity* follows from the decoupling of concepts and their completeness with respect to their purposes, so that critical properties are localized and modifications of one concept do not propagate to another. Improved *incrementality* follows from the independence of concepts, allowing each to be generated and modified without knowledge of others, and from the granularity of synchronizations, which often allows behavioral extensions to be expressed as the addition, deletion or replacement of small synchronizations.

Contemporary codebases often lack not only modularity but also *transparency*. When executions fail, it can be hard to figure out what happened, let alone why. Concepts and synchronizations allow greater transparency because control flow never passes from one concept to another without an explicit synchronization, so there is no need to look inside concepts (or worse, resolve the bindings of arguments or state components to callbacks) to figure out which actions occurred. Moreover, the synchronization engine produces action traces as a natural byproduct of execution, recording the *provenance* of each action so that auditing and problem diagnosis can be easily performed.

The contributions of this paper include a specification format for concepts (Section 4), a language for synchronizations (Section 5), and a design for an engine that executes synchronizations (Section 6). Together, these allow effective LLM-based generation of code for the backend of a web application. A case study was conducted (Section 7) for the RealWorld benchmark [14] (a Medium-like blogging application that has been implemented in over a hundred different technologies), serving as an evaluation of a realistic (if small) application, and offering examples that will be used for illustration throughout the paper.

## 2 Concepts

In his recent book [22], Daniel Jackson proposes “concepts” as a way to structure the functionality of a software system. Concepts are user-facing units of functionality that have a well defined purpose and thus deliver some recognizable value. For example, the concepts of a social media app might include *Post*, *Comment*, *Upvote*, *Friend*, *Password*, etc.

Together, the concepts of an application comprise its conceptual model, but importantly concepts are understandable independently of one another, and so when a concept refers to values from other concepts they are always treated as fully polymorphic. Thus, for example, in a social media app, the *Comment* concept would be defined so that a comment’s target can be any type of object, without any constraints or expectations, and in each particular app the targets will be concrete objects created by other concepts—for example, posts in a social media app, products in an online store, articles in a newspaper, and so on.

Concepts are often familiar to users, since the same concepts arise in (near) identical form in many different contexts. Indeed, this is what makes many applications readily usable, with the user bringing an understanding of most of the concepts from prior experiences with those same concepts in other applications.

In contrast to the way the word is sometimes used in other settings, a concept is not an element in an ontology. In the field of conceptual modeling, a “conceptual model” is often a data model in which the concepts are entities. Richer kinds of conceptual model have been defined that incorporate behavior, for example, by defining the concepts as objects (or more accurately classes) with their own internal behavior.

These approaches do not allow a modular treatment of concepts, however. The behavior associated with a concept typically involves multiple classes of objects, and modifications that involve their relationships to one another. For example, the behavior of the *Upvote* concept is to associate votes with both particular items and with the users who issued the votes (in order to prevent double voting).

In Jackson’s scheme, a concept is defined as its own state machine, with actions that can be performed by the user and a visible state. Thus the actions of the *Upvote* concept might be to *upvote*, *downvote* or *unvote*, each taking an item and a user as arguments; the state would include which votes were issued by which users, for which items, and whether they were upvotes or downvotes.

This idea of modeling behavior abstractly as a state machine is conventional, and central to almost all formal specification languages, including Alloy, B, VDM and Z. What is new is the separation of concerns that concepts embody, in which reusable facets of behavior are teased apart. For example, in contrast to a traditional object-oriented approach in which a *User* class might include usernames and passwords (for authentication), display names (for profiles), email addresses (for notification), and so on, in a concept design these would be factored into distinct concepts. There are many precedents to this idea, in view specification [20] and in aspect-oriented [25], role-oriented [29] and subject-oriented programming [17].

When concepts are composed into a system, the traces (behavioral histories) of the system as a whole are always interleavings of the traces of the individual concepts. The

properties of the concepts—as witnessed by the traces they permit—are thus preserved by definition. This means that many (but not all) of system properties can be localized within concepts. For example, the *Password* concept will guarantee that a user attempting to execute an authenticate action will succeed only when the presented password matches the one submitted earlier on registration. Whether actions of other concepts are appropriately authenticated, on the other hand, will depend on how those concepts are composed, so the property that a user cannot delete a post unless authenticated as its author, for example, will necessarily involve multiple concepts (eg, *Password* and *Post*) and the way in which they composed.

In his book [22], Jackson argued that concepts should structure not only the functionality visible to users but also the underlying implementation. A concept is thus at the same time both a protocol describing a pattern of human behavior and a service supporting it. In respect of implementation, concepts are thus similar to microservices, but whereas microservices can call each other and even query each others' state (often resulting in a tangled web of connections), concepts have no such dependencies. Nevertheless, a concept may have dependencies on lower level services, such as databases, networking services and datatype libraries.

## 3 Synchronizations

Concepts are orchestrated by an application layer that makes calls to concept actions and queries concept states in response to incoming requests. All data and control flow between concepts is expressed in the code of this layer. This is how coupling between the concepts themselves is avoided, allowing concepts to be designed independently and then composed later into applications.

One possible implementation pattern would be to write a procedure for each application endpoint that makes calls and queries to multiple concepts, assembles the resulting data, and then returns a response to the client. This is perhaps the simplest approach to understand and it corresponds most closely to standard practice in web applications. Indeed, this is how students in a senior-level software engineering class in the authors' university have been taught in previous years to realize concept design in their projects.

In his book [22], Jackson proposed a more granular mechanism for composing concepts, in which a set of concepts is coordinated with a set of *synchronizations*. Each synchronization has a firing condition that corresponds to the execution of a concept action, and causes the execution of one or more additional concept actions. The entire sequence of actions that results is required to form a transaction, so that if any action should fail, all the actions must be undone.

This scheme supports not only simple causal relationships (for example when a user comments on a post, a notification is sent to the post's author) but also allows actions to be used

for suppression. A synchronization might say that downvoting of a post through the action *Upvote.downvote(u,p)*<sup>1</sup> leads to the execution of an action *Karma.permit(u, 10)* representing the fact that user *u* is permitted to perform some (other) action requiring 10 karma points. If the user lacks the requisite karma points, that action fails, and so the original downvoting action will be aborted also.

The granularity of this mechanism supports a straightforward mapping of behavioral properties to synchronizations. There might be a separate synchronization, for example, for each of the following:

- Authentication: when a post is deleted, the user must be authenticated;
- Moderation: when a moderator rejects a post, the post is deleted;
- Cascade: when a post is deleted, its associated comments are deleted too;
- Notification 1: when a moderator rejects a post, its author is notified;
- Notification 2: when a comment is deleted, its author is notified.

Together, these synchronizations might define a complex sequence of actions: for example, that a moderator rejects a post, causing (a) the moderator to be authenticated, (b) the author of the post to be notified, (c) the post to be deleted, (d) the comments on the post to be deleted too, and (e) the authors of those comments to be notified. The granular structure makes it easier to enforce behavioral rules consistently, ensuring, for example, that comments on a post are deleted not only when the post is deleted explicitly by its author but also when it is deleted due to moderation.

Despite its advantages, this scheme has deficiencies:

- The causal model is not easy to understand, because it mixes a CSP-like [19] symmetrical rendezvous with a directed stimulus/response pattern.
- Transactions complicate the implementation, making it hard to implement actions, such as notifications, whose effect in the world must be delayed until the transaction commits.
- Extending synchronizations to fire on multiple actions, or to condition on concept state in rich ways, is challenging.
- It is not clear how to accommodate error handling.
- Synchronizations that require actions to be mapped over a set (for example, a cascading delete that should be applied to all comments associated with a deleted post) are not easy to specify.

A new synchronization scheme was therefore devised and is a key contribution of this paper. This scheme, described below, is more expressive, easier to understand and requires no transactions, all while preserving (and in some respects

<sup>1</sup>The concept is called *Upvote* since its purpose is to allow users to upvote items, but confusingly it also includes a *downvote* action.

improving) the ability to write granular synchronizations. The elements of this scheme are as follows:

- Synchronizations follow the simple causal structure of traditional event-based systems: when some actions occur under some conditions, some other actions are invoked.
- The firing condition of a synchronization can include any number of action occurrences, along with conditions on the states of any number of concepts, and when the rule fires, multiple actions can be invoked.
- By using free and bound variables that are scoped across the entire rule and implicitly quantified, firing can be predicated on concept states (for example, firing only on deletions of a post by its author), and actions can easily be invoked over a set (for example, deleting all the comments with a particular post as a target).

This scheme eliminates the need for transactional semantics, while still allowing synchronizations to be specified that fire on action failures (that is, actions that return errors or raise exceptions), thus allowing errors to be handled without special treatment.

A key insight that made this possible was to regard the incoming request as itself an action to which a synchronization reacts. A kind of “bootstrap concept” is introduced to model the user as the entry point of interaction, with a *request* action for an incoming request and a *response* action for a response.

Now, authentication and authorization can be handled in a more natural way. For example, to say that an *downvote* action can occur only when the user has some number of karma points, the synchronization would say “when a *request* is received for a *downvote* for item *i* by user *u*, where user *u* has at least *N* karma points, then the *downvote* action by *u* on *i* is invoked.”

## 4 Concept Specifications

Our specification language is mostly informal, except for the definition of state components and action signatures. Here, for example, is a specification for a *Password* authentication concept.

```
concept Password [U]
purpose
  to securely store and validate user credentials
state
  password: U -> string
  salt: U -> string
actions
  set [ user: U ; password: string ]
  => [ user: U ]
    generate a random salt for the user
    compute a hash of the password with the salt
    store the hash as password and salt in salt
    return the user reference
  set [ user: U ; password: string ]
```

```
=> [ error: string ]
if password does not meet requirements
  return the error description
check [ user: U ; password: string ]
=> [ valid: boolean ]
  retrieve salt for user
  compute hash of provided password with salt
  compare with stored hash
  return true if hashes match, false otherwise
check [ user: U ; password: string ]
=> [ error: string ]
  if user does not exist or has no password
  return the error description
validate [ password: string ]
=> [ valid: boolean ]
  check that the password meets requirements
  return true if valid, false otherwise
```

operational principle

```
after set [ user: x ; password: "secret" ]
=> [ user: x ]
then check [ user: x ; password: "secret" ]
=> [ valid: true ]
and check [ user: x ; password: "wrong" ]
=> [ valid: false ]
```

The specification is broken into named sections according to the structure in Jackson’s book [22]. The state section specifies the concept’s data model as a collection of relational state components in the style of Alloy [21]. The *password* and *salt* components, for example, associate a hashed password and a salt value with each user. Note that users are represented by a type variable *U* which is listed at the top as a parameter of the concept. Type parameters cannot be constrained, so this ensures no external coupling or dependence on whatever type is actually used to represent users.

The action section lists each of the concept’s actions with their signatures and informal specifications. Each action is split into cases in the pattern-matching style of functional programming languages; in this example, the input arguments always take the same form, and the cases happen to be split only on the output arguments. Each action can take any number of arguments and return any number of results. The names of the arguments and results are significant. This will be important both to allow matching in synchronization rules on only a subset of arguments, and also to distinguish normal and exceptional outcomes. The *set* action, for example, which sets the password of a user, takes (a reference to) the user and a string representing the password, and returns either the same user (when the action is successful) or an error message (otherwise). Note that the specification of the action is only partial; it does not enumerate the well-formedness rules for passwords, for example, because these details are not needed for synchronizations.

The operational principle is a kind of archetypal scenario that describes how the concept fulfills its purpose, and plays

a useful role both in understanding the concept and in generating test cases.

Concept specifications can play a variety of roles. Most importantly, they define the interfaces to synchronizations. They can be extracted from concept code, but can also be used to generate concept code. They can be written by human designers, or generated by an LLM. In this case, the *Password* concept was generated by an LLM in response to a minimal prompt (see Section 7.3), and was then used to generate the concept code as well. The prompt asked only for a standard password concept, but the LLM included details of hashing and salting in both the specification and the generated implementation. Two other concepts (see Appendix B) that involve users were defined for the case study: a *User* concept that allows users to be identified by email addresses or usernames, and a *Profile* concept that associates with users information for public display.

Concepts, unlike abstract data types, expose their states to the application layer, albeit in an abstract form. This is important for three reasons:

- It saves designers and programmers from the trouble of having to anticipate (and then deliver on) all the different ways in which the state may be queried.
- It allows synchronizations to use database queries that cross concept boundaries—for example, delivering the bio from a user’s profile given their username, joining the relations of the *User* and *Profile* concepts—which makes code simpler, more uniform and more efficient.
- It preserves the idea that concept behaviors are user-facing, which treating state observations as actions would compromise. This does not mean that all actions have to update state; the check action of the *Password* concept is genuinely an action that would make sense to a user (in contrast, for example, to an observer action that merely obtains a reference to a user from the user’s email address, a query that synchronizations might perform for reasons that are of no interest to the user).

## 5 Synchronization Language

Synchronizations describe how the actions of independently defined concepts interact, and have the standard form: “*when* these actions happen, *where* the current state of things are so, *then* these actions should follow.” The examples below illustrate the expressivity and legibility of this form.

### 5.1 A Basic Synchronization

Our first example illustrates the basic ideas and structure of a synchronization for a simple user registration flow:

```
sync Registration
when {
  Web/request: [
    method: "register" ;
    username: ?username ;
    email: ?email ]
}
```

```
=> [ ] }
where { bind ( uuid() as ?user ) }
then {
  User/register: [
    user: ?user ;
    name: ?username ;
    email: ?email ] }
```

This says: when a Web request for register occurs for some ?username and ?email, bind a new uuid() as ?user, and register a new user with that ?user identifier, and with a name of ?username and an email of ?email.

The parts (all required except for where) are:

- *sync*: a unique name for the synchronization hinting at its purpose;
- *when*: a pattern for matching action *completions* (actions that have returned with an output, denoted by the => pointing to a pattern for the output record);
- *where*: a query on the states of one or more concepts, as well as any calculations not requiring state;
- *then*: a list of action *invocations* to be executed by their associated concepts (action patterns without a =>).

Clauses may include (in syntax similar to SPARQL [16]):

- Literals (such as strings and numbers);
- Variables (with a question mark) that match action arguments or state components;
- Namespaces (such as Concept: for a concept, or Concept/action: for an action) that fully qualify all property names within;
- Properties (property:) which appear within brackets, and are *context-specific* and qualified by the surrounding namespace. Inside a Concept/action: namespace, these refer to the input and output arguments of that action; inside a Concept: namespace, (illustrated in the where clause of examples below) these refer to the state relations of that concept.

### 5.2 Granularity and Partial Matching

Actions in the when clause can match solely based on the specified arguments, allowing for enhanced granularity. After a User registration, the following synchronization handles setting a Password:

```
sync NewPassword
when {
  Web/request: [
    method: "register" ;
    password: ?password ]
=> [ ]
  User/register: [
    => [ user: ?user ] ]
}
then {
  Password/set: [
    user: ?user ;
    password: ?password ] }
```

Notice that the input pattern for `User/register` is empty, indicating that for the purposes of this synchronization, any successful registration (denoted by the `user:` argument present in the output; see Appendix B.1 for the full concept specification) is grounds for setting a password. The other condition is a `Web/request` for the "register" method, which could contain more arguments—as seen in the previous section—but which do not need to be specified here.

### 5.3 Errors and Flows

Error handling involves matching on outputs that are errors:

```
sync RegistrationError
when {
  Web/request: [ ]
    => [ request: ?request ]
  User/register: [ ]
    => [ error: ?error ]
} then {
  Web/respond: [
    request: ?request ;
    error: ?error ;
    code: 422 ]
}
```

This example demonstrates how error handling can be modeled without special features or language extensions. The `error:` argument is simply another name for the purposes of pattern matching, and is fully defined in one of the action overloads in the concept specification. Different kinds of exception or result are thus easily defined.

This example also illustrates multiple actions in the `when` clause. To match, such actions must have occurred *in the same flow*<sup>2</sup>. Here, the synchronization says “when a web request occurs, and a user registration fails, respond with an error about that failure.” The link between the user registration failing and the specific web request, implicit in the flow, is essential, as other web requests may be in process at the same time.

### 5.4 Expressing Design Decisions

The synchronizations seen so far are unremarkable and almost inevitable. But synchronizations can also be used to express application-specific design decisions in a granular manner. For example, a synchronization may create a default profile for a user when they register successfully:

```
sync DefaultProfile
when {
  User/register: [ ]
    => [ user: ?user ]
} where { bind ( uuid() as ?profile ) }
then {
  Profile/register: [
    profile: ?profile ;
    user: ?user ]
}
```

<sup>2</sup>A flow is a directed acyclic subgraph of action occurrences with its root in an external action, such as a user input or HTTP request. A more detailed treatment is given in Section 6.3.

or generate a fresh JWT token on registration, logging the user in implicitly:

```
sync NewUserToken
when {
  User/register: [ ]
    => [ user: ?user ]
} then {
  JWT/generate: [ user: ?user ]
}
```

### 5.5 Fusing Data from Multiple Concepts

A final example shows how a synchronization can assemble a formatted response body:

```
sync RegistrationResponse
when {
  Web/request: [ method: "register" ]
    => [ request: ?request ]
  User/register: [ ] => [ user: ?user ]
  Profile/register: [ ] => [ profile: ?profile ]
  Password/set: [ ] => [ user: ?user ]
  JWT/generate: [ ] => [ ] ]
} where {
  User: {
    ?user
    name: ?username ;
    email: ?email }
  Profile: {
    ?profile
    bio: ?bio ;
    image: ?image }
  JWT: { ?user token: ?token }
} then {
  Web/respond: [
    request: ?request ;
    body: [
      user: [
        username: ?username ;
        email: ?email ;
        bio: ?bio ;
        image: ?image ;
        token: ?token ] ] ] ]
}
```

Most of the actions have empty argument lists, since the synchronization depends only on awaiting their successful completion and then formulating a response from the resulting state of their respective concepts.

The complexity of this synchronization (which is taken from the case study described below) reflects the ad hoc nature of the API design, and the conflation of multiple concepts in a single response. Nevertheless, it is important for synchronizations to be expressive enough for such cases.

## 6 Architecture

The architecture comprises:

- **Concept implementations:** independent services that manage their own state, accept action *invocations*, perform side effects, and respond with action *completions*.

- The synchronization engine: a service that allows synchronizations to be registered, accepts *completions*, and records action *invocations* for actions to be performed.

The synchronization engine can be thought of as a reactive database that holds action invocation and completion records, with completions triggering actions within independently running concepts. In our implementation, the concepts are implemented as modules that execute in the same thread as the engine, with the engine calling concept actions directly. Other schemes are possible: concepts might run as separate processes, and a variety of push/pull event frameworks could be used to link the engine and concepts, allowing latency and consistency to be balanced in different ways.

To deliver legibility, where “what you see” truly is “what it does,” an implementation scheme must satisfy some essential properties, which we enumerate in subsequent sections along with the solutions we adopted.

### 6.1 Naming

Names are often a source of confusion and illegibility: does user refer to a class, an argument, or an identifier? How about names associated with different versions, environments, and applications? Each name must have a direct mapping to a unique identifier.

One approach is to use the Resource Description Framework [7] to map names in concept specifications to Uniform Resource Identifiers (URIs). For example, the password argument of the Password concept’s set action might be:

```
https://essenceofsoftware.com/  
    concepts/0.1/Password/set/password
```

The last three elements of the URI correspond to the three levels of names in concept specifications: concept, action and argument. Synchronizations themselves are given names too, which prove essential for auditing and debugging.

For the case study, we used an RDF-based graph store to represent concept states, which allows predicates (relations in the concept specification) to be fully qualified names. In a more traditional setting, say of a relational database, mappings might be needed, e.g. from a column name in a table to its fully qualified name.

Argument order conventions for calling APIs can reduce legibility for unfamiliar developers or LLMs. To avoid this, we use named arguments for actions, which are easily implemented with functions that take and return a dictionary object. As explained earlier, named arguments are essential for partial pattern matching as well.

### 6.2 Versioning and Causal Documentation

Every record in the state of a running application is associated implicitly with a particular version of the concepts and synchronizations that produced it. This can be made explicit, by including in every record a reference to the application

version, thus establishing a causal link between the state record and the documentation that explains it.

In our case study implementation, we leverage the built-in ability of RDF quad stores (subject, predicate, object, graph) and co-opt the graph identifier for this purpose, which allows the states of multiple versions of the running application to co-exist in the database without confusion. This approach eases transitions between staging and production environments and offers a path towards multi-tenancy (more details in Appendix A.2).

### 6.3 Scoping via Flows

Traditional route handlers are often unwieldy, with control structures for handling different request variants, conditions and errors. This damages legibility and makes it hard for LLM and human coders alike to adjust or augment the behavior associated with a web request. Synchronizations reduce this complexity and improve legibility, by replacing elaborate imperative code with granular and declarative rules.

Nevertheless, the traditional routes have one advantage: that the scope of each test and action is clearly tied to a single web request. In our scheme, this scoping is implicit, and is achieved by associating a *flow* token with all action records (see Appendix A.3.2 for implementation details), and propagating the token through synchronizations. All action records matched in a synchronization’s when clause must carry the same flow token, and if the synchronization succeeds, all invocations in the then clause will be given the same token. Consequently, given an initial action, all cascading synchronizations will result in a set of causally related actions associated with the same token.

### 6.4 Modularity of State

The modularity of concepts can be compromised in (at least) two ways. One is the proliferation of “getters” driven by the query needs of clients and thus coupling concepts to synchronizations. Our solution to this is simply to have no getters. Reads and writes are strictly separated: reads are handled by client-driven querying capabilities such as GraphQL [15] and writes are handled directly by the action API. In our case study, we exploited the RDF ecosystem, using a SPARQL [16] query engine (the Comunica [32] library) to provide federated read access to concept states.

The other is the temptation to include in the schema—of the state of a concept—references to schema components of other concepts (eg, through a foreign key). We avoid this by representing all external references with UUIDs. Unfortunately a lack of support for polymorphism in database schemas (at least in the platforms we are familiar with) means that static checking cannot yet ensure that such references are used consistently.

### 6.5 Implementing the Where Clause

Reads and writes are separated in a concept interface, with reads implemented as database queries and writes as actions. Concepts do not query each other’s states, but synchronizations can query them, often across multiple concepts (another important reason to prefer queries over getters). An implementation must therefore translate the declarative patterns of the synchronization where clause into whatever queries are suitable for the concept implementations.

The where clause is given a uniform semantics as a function from a single binding to a set of bindings (each binding comprising values for a given set of variables). The incoming binding will hold the values of the variables bound in the when clause; the outgoing bindings will hold the values of variables that resulted from database queries, and will be used in the then clause, with one invocation of the clause for each resulting binding. For example, in a synchronization that cascades a deletion of a post to the deletion of all its comments, the query might map a single binding with a reference to the post to multiple bindings, one for each comment associated with it, allowing a simple declarative specification without needing any explicit iteration.

In the case study implementation, all concept databases are RDF-compatible graph stores, and so a SPARQL [16] engine provides this natively (given some code that expands names of concepts and actions in context to their fully qualified forms as named graph patterns).

### 6.6 Provenance and Firing Consistency

The synchronization engine can fail during the processing of synchronizations, but should be able to recover and resume execution seamlessly. To ensure both atomicity and idempotency of synchronizations, preventing duplicate invocations, an implementation must durably record synchronization evaluation itself and provide a mechanism to determine what has already occurred.

One solution is to augment the engine’s state with *synchronization edges* that connect each action occurrence back to each of the actions that precipitated it, labeled by the name of the synchronization (see Appendix A.3.2 for implementation details). A synchronization is then activated only for a particular action completion if there is no existing outgoing edge (to some invocation) from that completion, labeled with the synchronization’s unique identifier.

This strategy allows for all records to be reevaluated on reboot during failure to resume execution. Along with flow tokens, this allows provenance tracking in which each action occurrence can be traced back both to its causal predecessors at runtime and to the synchronizations that produced it.

### 6.7 Bootstrapping: The Web Concept

For the engine scheme to work, there need to be root actions that correspond to external stimuli. These actions are treated

as the actions of a special bootstrap concept. In our case study implementation, since these actions originate as HTTP requests, the Web concept encapsulates the details of HTTP request and response structures.

At the same time, this concept can be viewed as a proxy for actions performed in the world that connect the application to it. These actions can always be identified easily in the set of synchronizations, since they are the only ones that have completions but no invocations. This bootstrap concept is therefore the entry point to the system, and encapsulates various configuration and operational concerns.

## 7 RealWorld Case Study

RealWorld [14] is a benchmark for comparing platforms for web applications. It was inspired by the success of TodoMVC, a site that showcased implementations of a simple to-do app, but was limited to frontend frameworks. RealWorld specifies a common service API, and includes both frontend and backend implementations, which can (in theory at least) be tested in arbitrary combinations. The benchmark application is Conduit, a Medium-like blogging platform in which authors post articles, and readers can comment, tag, and favorite articles, follow other users, and so on. RealWorld aims to be the “mother of all demo apps,” and currently over 100 implementations are included.

The RealWorld API is only minimally documented, and consists primarily of a collection of JSON declarations specifying the format of expected responses. In concept design terms, the API conflates concerns that could be separated into distinct concepts and distinct API calls. For example, the API call to unfollow a user returns that user’s profile (including their bio); similarly, calls to obtain articles return, along with the article author’s username, all the author’s profile fields, whether or not the author is being followed, and how many times the article has been favorited. These complications provide a helpful challenge, since the ability to meet this spec would imply that a more cleanly organized API would be even more easily delivered.

The key goals of the case study were to determine (a) whether the benchmark app could be straightforwardly programmed using concepts and synchronizations; (b) how readily the concepts and synchronizations of the backend could be generated by an LLM; (c) and what surprises programming in this style might bring.

### 7.1 Generating Specifications and Code

To demonstrate feasibility and expressiveness, we first built a full RealWorld backend implementation of Conduit with concepts and synchronizations written by hand, and checked that it passed the provided automated Postman test suite.

We then used an LLM to generate a complete, second version of the codebase. For each concept, we generated a specification from a brief prompt (see the Appendix for

examples), and then generated code from the concept specification. Importantly, the LLM's context for the generation of both concept specifications and code is limited to the concept at hand. These generation steps almost all completed successfully in a single shot.

We then generated the synchronizations. Here the context included only concept specifications and no code. The prompts included (a) some general and rather vague requests to generate typical synchronizations for these concepts; (b) a few hints for special cases (eg, that a default profile should be created on registration); and (c) the JSON response formats of the endpoints specified in the RealWorld benchmark (to account for the idiosyncratic packaging of results).

Generating the synchronizations required some iteration. After the synchronizations were generated, we ran the Postman test suite which sometimes revealed errors suggesting additional synchronizations. We also ran some ad hoc tests which pointed to further missing synchronizations (for example, ensuring that the user deleting a comment is the author, a requirement that the standard test suite does not enforce).

Throughout this generation process, we aimed to align the LLM's knowledge of the framework with documentation intended for human consumption. To generate the synchronizations, for example, we used (an earlier version) of Section 5 as the system prompt. This proved useful when early failures of LLM generation exposed flaws in our explanation.

### 7.2 Design Rules

We have yet to conduct a systematic comparison of the existing benchmark implementations with ours. But an initial analysis illustrates some of the respects in which our approach may offer improved modularity and legibility.

A programmer seeking to change or extend an application's behavior relies on *design rules* that confine changes within a limited scope. These design rules, often implicit, may arise from a framework that dictates the structure of the code, from common design patterns or programming styles, or from design decisions made by the programmer.

For example, most of the RealWorld implementations have three separate layers: a routing layer that manages URL and request structures; a controller layer that handles business logic; and a data or model layer that persists the data. Each layer is intended not only to separate concerns (eg, separating data usage in the controller layer from data representation in the model layer), but also to encapsulate technological dependencies (eg, on HTTP in the router layer and on the particular database in the model layer).

Each layer, moreover, is split into modules, usually along object-oriented lines, with one file for each entity. RealWorld implementations, for example, will typically have routing, controller and model modules for articles, users, tags, etc.

The design rules determine not only these organizational principles, but also constrain dependencies. Modules within

a layer typically may not call each other: thus routing modules call only controller modules, which in turn only call model modules, and only model modules are expected to make database calls. Dependencies are also confined within entities: thus the router for articles is expected to call functions only in the articles controller, which is then expected to use only the articles model.

Finally, a more informal design rule maps functionality to entities. Functions associated with articles, for example, are expected to be within the article modules.

Examining a few RealWorld implementations, we found that their design rules are frequently violated<sup>3</sup>:

- Controllers include database accesses that bypass the model layer [a];
- Controllers access the models of other controllers (article accesses user [a,b,c]; article accesses tag [a,b]; tag accesses article [b]);
- Routers are not always limited to their controllers (article router calls comment controller [a]).

The mapping of functionality to entities is often uncertain, because several areas of functionality are not neatly contained within entities. Different aspects of favorites, for example, are updated by functions in both the article and user schemas [a], and tagging is handled by controllers for both articles and tags [a].

Our approach, likewise, imposes design rules:

- Concept actions do not call actions or access the state of other concepts;
- State declarations in one concept have no dependencies on state declarations in another;
- Synchronizations only access concept states and actions;
- Only a single bootstrap concept can initiate actions, and encapsulates front-end commitments (such as the use of HTTP).

Our implementation respects these design rules by construction: the generation process isolates concepts from one another, and synchronizations from knowing the structure of the code. Synchronizations confine reads of action records to the *when* clause and reads of concept state to the *where* clause. The bootstrap concept is predefined and independent of any domain-specific code, so its properties are easily preserved.

The mapping of functionality to concepts is straightforward, since concepts (unlike entities) naturally accommodate relational aspects. Our implementation thus encapsulates favorite and tag related behaviors in the two corresponding concepts. In contrast, none of the standard implementations we looked at has a model for favoriting, which gets squeezed

<sup>3</sup>The implementations cited here are:

a. <https://github.com/SeuRnao/realworld-express-prisma>  
b. <https://github.com/gearhead041/realworld-nestjs-prisma-mongodb>  
c. <https://github.com/winterrrrfff/realWorld-server>

inconsistently into the user or article model, and may even appear in both [c]. Even an implementation that includes a tag model does not use it to contain all tag-related functionality [c], perhaps due to an object-oriented tendency to regard tags as properties of articles. Our implementation encapsulates translation from usernames to user ids in a single concept; one conventional implementation encapsulates it with following in a profile service [b]; one encapsulates it in a free-standing utility function [a]; and another does not encapsulate it at all [c].

### 7.3 Case Study Reflections

On the positive side, concepts and synchronizations enabled a very granular and incremental style of development. As illustrated in Section 5, the synchronizations for aspects of user management, profile updates, and authentication could be completed independently and step by step. Notably, each synchronization directly implemented the functionality specified, without requiring a larger scope of code (such as the rest of a “route”) to be completed. For example, after writing the synchronizations for initiating a User/registration when a Web/request happens, running an HTTP request against the application results in a registration, which can be confirmed independently in the User database, even without a synchronization that produces a web response.

While interacting with an LLM, the intermediate specification language was a useful substrate for conveying specific changes or design choices. For example, the first pass generation for a Password concept, with the generic prompt “Create a Password concept”, resulted in a design incorporating the additional actions of reset and completeReset that handled a secure password reset with a temporary reset token in the state. While this is a serviceable choice, this reset behavior can be handled in a more modular way, by synchronization with a concept like JWT. Since the prompt for the implementation is exactly the concept design spec, simply removing these two actions and the single state component (resulting in the example in Section 4) generated the final working implementation in a single pass.

In general, working on top of the specification language allowed a more direct and reliable manipulation of code than issuing prompts in terms of the code would have. When working on the Profile concept, adding a user thumbnail image was achieved within the specification: the LLM proposed to add an image state and two update action overloads, and generated a working version with the proper implementation. Throughout the overall process, conversational steps were mostly budgeted toward clarifications and choices about design at the specification layer, with fewer spent on implementation and generation of code.

On the negative side, the extreme granularity of synchronizations, and the fragmentation of the conditions under which an action is invoked, made it harder to understand the full context of a series of actions at a glance. A compensation,

however, is that behavior that would be replicated across multiple endpoints in a traditional implementation was often factored into a single synchronization.

In generating specifications, LLMs can be over enthusiastic (as the password reset example above illustrates). The system prompt does not provide extensive guidance on proper concept design, and the abundance of object-oriented approaches in training material for many models today can result in designs that do not yet fully capitalize on the modularity that concepts and synchronizations make possible.

### 7.4 A Bug Fixing Story

The properties of our framework are illustrated not only when generation succeeds (especially in the dramatic reduction of the LLM context that it enables) but also when it fails.

The following example shows how we exploited the provenance properties in debugging a faulty synchronization:

- By querying the graph of executed actions for a single flow, we were able to see the causal links between actions and trace back to the initiating action.
- Since all action occurrences are labeled by the synchronization responsible for them, we were easily able to find the code responsible for undesirable actions.

The bug in question involves the user registration flow presented in Section 7, which actually exhibits an undesirable behavior. After a user attempts a registration with a bad password, a subsequent registration attempt with the same username or email will fail.

The provenance properties offer a general strategy for debugging: (1) issue a query identifying the flow of the undesirable behavior, and (2) provide the identified synchronizations to the LLM to reason about. In this case, given the request-id for a client experiencing the bug, we queried over the Web/request actions bound to that specific id, and discovered the relevant flow and associated synchronizations.

The subset of synchronizations was given to an LLM, along with the following prompt: “*With these syncs, when I register with a bad password, the next time I try with a good one the system complains that a user already exists. How can I fix this?*”. In response, the LLM correctly identified the problem:

*The issue is happening because your current synchronization flow is creating the user before validating the password. When a user tries to register with an invalid password:*

1. *The user is created in the database via ‘User/register’*
2. *Then ‘Password/set’ fails with validation error*
3. *When they try again with a valid password, the system rejects it because the username/email already exists. To fix this, we need to validate the password before creating the user. Here’s how to modify your synchronizations...*

The LLM proposed to realign the Web/request with Password/validate instead by adding a new synchronization, and modifying the existing Registration to condition on successful validation:

```
sync ValidateRegistrationPassword
when {
  Web/request: [
    method: "register" ;
    password: ?password ]
    => [ request: ?request ] }
then { Password/validate: [ password: ?password ] }

# Only register user if password is valid
sync Registration
when {
  Web/request: [
    method: "register" ;
    username: ?username ;
    email: ?email ;
    password: ?password ] => [ ]
  Password/validate: [ password: ?password ]
    => [ valid: true ] }
where { bind ( uuid() as ?user) }
then {
  User/register: [
    user: ?user ;
    name: ?username ;
    email: ?email ] }
```

These synchronizations, along with one additional generated synchronization for now responding on failed validation, successfully solved the issue without affecting any other existing behavior. In total, two synchronizations were added, one was altered (Registration), while the existing behaviors of default profile creation, login token on registration, and response format continued to function as before.

This example highlights the possibility of future instrumentation that:

1. upon a user marking an undesirable action, automatically marks all related actions in the flow;
2. gathers the responsible syncs through code provenance;
3. generates a semantic account of the issue and possible solution;
4. forks a separate action graph to test the solution and provide the updated behavior by replaying the same inputs/outputs from the identified flow.

## 8 Related Work

Improving modularity (and trying to explain exactly what it means) has been a focus since the earliest days of programming. David Parnas [26] coined the term “information hiding” for the criterion that each module should be “characterized by knowledge of a design decision.” As an example, he recommended encapsulating the definition of a data structure

and its access methods, which eventually led to the notion of data abstraction and representation independence.

A few years later, and seemingly unaware of Parnas’s earlier work, Stevens, Myers and Constantine proposed “coupling and cohesion” as general principles for modularization [30], which became a key part of Yourdon and Constantine’s structured design [34]. Concepts can be viewed as an attempt not only to minimize coupling (by disallowing all references between concepts) but also to maximize cohesion, by colocating functions associated with a purpose in the world. In structured design itself, cohesion was determined instead by control and dataflow patterns in the code.

Parnas subsequently clarified the idea of coupling by articulating the idea of module dependencies (which he called the “uses relation”) [27], and formulated a powerful principle: that a module  $A$  should only use a module  $B$  if in so doing  $A$  is easier to implement, and there is no useful subset that contains  $A$  but not  $B$ . As noted in Jackson’s book [22] (pp. 274–276), this principle is systematically violated by the most common object-oriented programming practices.

Modularity has been heralded as the key to design in other disciplines too, notably in the use of the design structure matrix for optimizing processes [10] and in arguments that modularity brings economic advantages as options that can be exercised as designs evolve [3].

Concepts are similar to microservices [13] in spirit although in practice microservices are not kept independent and often end up in a tangle of dependencies. The “aggregates” of domain driven design [11] also share the goal of encompassing the functionality relevant to a purpose, but do not usually form modules.

Many modularity schemes can be viewed as attempts to realize Dijkstra’s notion of “separation of concerns” [9]. Views and viewpoints offered a separation of concerns in specifications [1, 8, 12, 20]. The tendency of object-oriented programming to conflate concerns has been widely recognized, and many remedies have been proposed [17, 25, 29]. The aspects of aspect-oriented programming (AOP) are perhaps closest to concepts, but aspects are augmentations of a base program rather than independent modules. Moreover, aspects are not used to encapsulate all concerns, but only those that are “cross cutting,” which means not readily encapsulated by standard object-oriented mechanisms.

A synchronization is a kind of mediator [31], a mechanism that allows functional units to be completely decoupled from one another, despite data and control flows between them at runtime. In Sullivan’s scheme [31], the functions that form the API of a functional unit are distinct from the events that it can signal; the mediator calls functions in response to event occurrences. Concepts, in contrast, have only actions, which act as both API functions and events.

## 9 Future Prospects

By structuring code with concepts and synchronizations, LLM-based tools can offer more than “vibe coding” in which results are unpredictable, limits of complexity are easily reached, and each new coding step risks undermining previous ones.

We have seen that synchronizations can be used to factor out error handling and also the presentation/packaging of response data. Another possibility (which the authors have successfully prototyped) is to factor out the choice of persistent storage. The actions of each concept take an additional argument and result corresponding to the state before and after execution, and become pure functions. A database concept that is responsible for storing state persistently, and which hides the design secret of the choice of database system, can then be synchronized with these functional concepts. A concept’s actions can even be written using updates on conventional JavaScript objects as if they were mutable, using a framework such as Immer.js [28].

Distributed implementations might be achieved by allowing concept instances to run on different servers, with synchronizations as the mechanism to keep servers in step. A weakening of the synchronization semantics might allow eventual consistency. Sharding might be handled by multiple instances of a concept, each covering a set of domain objects (holding, for example, the passwords of a subset of users) with synchronizations used to determine which sharded concept instance to send an action to.

A less technically (but more socially) challenging advance that might radically alter the development of software would be the development of concept catalogs: libraries of concept designs and implementations for particular domains. Concepts within the catalog might be reviewed or even verified for correctness, so that application development becomes primarily the creation of suitable synchronizations for existing concepts. In this world, the concepts form a new kind of high-level programming language, with their actions as operations; synchronizations are then the programs written in this language.

## Acknowledgments

This research benefited greatly from prior work by Abutalib Namazov, who built the first prototype scheme for generating code using concepts with an LLM; from concept coding experiments by Jennifer Lawrence; from very helpful guidance on framing and clarity by the anonymous reviewers; and from discussions with Geoffrey Litt, Kevin Sullivan, Nick Phair, and John David Nurme.

This work was partially funded by the Machine Learning Applications (MLA) Initiative of CSAIL Alliances managed by the Computer Science and Artificial Intelligence Lab of MIT. The initiative board at the time of funding consisted of British Telecom, Cisco, and Ernst and Young.

## References

- [1] M. Ainsworth, A. H. Cktumcsmmm, L. J. Groves, and P. J. L. Wallis. 1994. Viewpoint Specification and Z. *Information and Software Technology* 36, 1 (1994), 43–51. [doi:10.1016/0950-5849\(94\)90007-8](https://doi.org/10.1016/0950-5849(94)90007-8)
- [2] Reem Aleithan, Haoran Xue, Mohammad Mahdi Mohajer, Elijah Nnorom, Gias Uddin, and Song Wang. 2024. SWE-Bench+: Enhanced Coding Benchmark for LLMs. [arXiv:2410.06992](https://arxiv.org/abs/2410.06992) [cs.SE]
- [3] Carliss Baldwin and Kim B. Clark. 2000. *Design Rules, Vol. 1: The Power of Modularity*. MIT Press. [doi:10.7551/mitpress/2366.001.0001](https://doi.org/10.7551/mitpress/2366.001.0001)
- [4] David Beckett, Tim Berners-Lee, Eric Prud’hommeaux, and Gavin Carothers. 2014. *RDF 1.1 Turtle: Terse RDF Triple Language*. W3C Recommendation. World Wide Web Consortium (W3C). <https://www.w3.org/TR/turtle/>
- [5] Tim Berners-Lee. 2006. Linked Data. Design Issues, W3C. <https://www.w3.org/DesignIssues/LinkedData.html> Updated 2009.
- [6] Tim Berners-Lee, James Hendler, and Ora Lassila. 2001. The Semantic Web. *Scientific American* 284, 5 (May 2001), 34–43. [doi:10.1038/scientificamerican0501-34](https://doi.org/10.1038/scientificamerican0501-34)
- [7] Richard Cyganiak, David Wood, and Markus Lanthaler. 2014. *RDF 1.1 Concepts and Abstract Syntax*. W3C Recommendation. World Wide Web Consortium (W3C). <https://www.w3.org/TR/rdf11-concepts/>
- [8] J. Derrick, H. Bowman, and M. Stetsen. 1995. Maintaining cross-viewpoint consistency using Z. In *IFIP International Conference on Open Distributed Processing*. Chapman and Hall, 395–406. [doi:10.1007/978-0-387-34882-7\\_32](https://doi.org/10.1007/978-0-387-34882-7_32)
- [9] Edsger W. Dijkstra. 1974. On the role of scientific thought (EWD 447). <http://www.cs.utexas.edu/users/EWD/ewd04xx/EWD447.PDF>.
- [10] Steven D. Eppinger and Tyson R. Browning. 2012. *Design Structure Matrix Methods and Applications*. MIT Press. [doi:10.7551/mitpress/8896.001.0001](https://doi.org/10.7551/mitpress/8896.001.0001)
- [11] Eric Evans. 2003. *Domain-Driven Design: Tackling Complexity in the Heart of Software*. Addison-Wesley.
- [12] A. Finkelstein, J. Kramer, B. Nuseibeh, L. Finkelstein, and M. Goedicke. 1992. Viewpoints: A Framework for Integrating Multiple Perspectives in System Development. *International Journal of Software Engineering and Knowledge Engineering* 2, 1 (1992), 31–57. [doi:10.1142/S0218194092000038](https://doi.org/10.1142/S0218194092000038)
- [13] Martin Fowler. [n. d.]. Microservices. <https://martinfowler.com/articles/microservices.html>. Accessed: 2025-04-24.
- [14] Goththinkster. 2023. RealWorld: The mother of all demo apps. <https://github.com/goththinkster/realworld>. Accessed: 2025-04-24.
- [15] GraphQL Foundation. 2021. GraphQL Specification. GraphQL Specification. <https://spec.graphql.org/October2021/> Version: October 2021.
- [16] Steve Harris and Andy Seaborne. 2013. *SPARQL 1.1 Query Language*. W3C Recommendation. World Wide Web Consortium (W3C). <https://www.w3.org/TR/sparql11-query/>
- [17] William Harrison and Harold Ossher. 1993. Subject-Oriented Programming (A Critique of Pure Objects). In *Proceedings of the Conference on Object-Oriented Programming Systems, Languages, and Applications (OOPSLA)*. [doi:10.1145/165854.165932](https://doi.org/10.1145/165854.165932)
- [18] Carl Hewitt. 2015. Actor Model of Computation: Scalable Robust Information Systems. [doi:10.48550/arXiv.1008.1459](https://doi.org/10.48550/arXiv.1008.1459) arXiv:1008.1459 [cs.PL]
- [19] C.A.R. Hoare. 1985. *Communicating Sequential Processes*. Prentice Hall. <http://www.usingcsp.com/cspbook.pdf>
- [20] Daniel Jackson. 1995. Structuring Z Specifications with Views. *ACM Transactions on Software Engineering and Methodology* (1995). [doi:10.1145/226241.226249](https://doi.org/10.1145/226241.226249) TOSEM.
- [21] Daniel Jackson. 2006. *Software Abstractions: Logic, Language, and Analysis*. MIT Press.
- [22] Daniel Jackson. 2021. *The Essence of Software: Why Concepts Matter for Great Design*. Princeton University Press. [doi:10.2307/j.ctv1n340p](https://doi.org/10.2307/j.ctv1n340p)

[23] Carlos E. Jimenez, John Yang, Alexander Wettig, Shunyu Yao, Kexin Pei, Ofir Press, and Karthik Narasimhan. 2024. SWE-bench: Can Language Models Resolve Real-World GitHub Issues? [doi:10.48550/arXiv.2310.06770](https://arxiv.org/abs/2310.06770) arXiv:2310.06770 [cs.CL]

[24] Elizabeth Barnes, Joel Becker, Nate Rush and David Rein. 2025. Measuring the Impact of Early-2025 AI on Experienced Open-Source Developer Productivity. *arXiv preprint* (2025). [doi:10.48550/arXiv.2507.09089](https://arxiv.org/abs/2507.09089) arXiv:2507.09089 [cs.SE]

[25] Gregor Kiczales, John Lamping, Anurag Mendhekar, Chris Maeda, Cristina Videira Lopes, Jean-Marc Loingtier, and John Irwin. 1997. Aspect-Oriented Programming. In *Proceedings of the European Conference on Object-Oriented Programming (ECOOP)*. [doi:10.1007/BFb0053381](https://doi.org/10.1007/BFb0053381)

[26] David Parnas. 1972. On the criteria to be used in decomposing systems into modules. *Commun. ACM* 15, 12 (1972), 1053–1058. [doi:10.1145/361598.361623](https://doi.org/10.1145/361598.361623)

[27] David Parnas. 1979. Designing Software for Ease of Extension and Contraction. *IEEE Transactions on Software Engineering* SE-5, 2 (April 1979), 128–138. [doi:10.1109/TSE.1979.234169](https://doi.org/10.1109/TSE.1979.234169)

[28] Michel Rauch and Immer.js contributors. 2023. Immer: Create the next immutable state by mutating the current one. <https://github.com/immerjs/immer>. Accessed: 2025-04-21.

[29] Trygve Reenskaug, Per Wold, and Odd Arild Lehne. 1996. *Working with Objects: The OOram Software Engineering Method*. Manning/Prentice Hall. [doi:10.17632/8tj2d5gh7b.1](https://doi.org/10.17632/8tj2d5gh7b.1)

[30] W. P. Stevens, G. J. Myers, and L. L. Constantine. 1999. Structured Design. *IBM Systems Journal* 38, 2&3 (1999). [doi:10.1147/sj.132.0115](https://doi.org/10.1147/sj.132.0115)

[31] Kevin Sullivan and David Notkin. 1992. Reconciling environment integration and software evolution. *ACM Transactions on Software Engineering and Methodology* 1, 4 (July 1992), 229–286. [doi:10.1145/131736.131744](https://doi.org/10.1145/131736.131744)

[32] Ruben Taelman, Joachim Van Herwegen, Miel Vander Sande, and Ruben Verborgh. 2018. Comunica: a Modular SPARQL Query Engine for the Web. In *Proceedings of the 17th International Semantic Web Conference*. [doi:10.1007/978-3-030-00668-6\\_15](https://doi.org/10.1007/978-3-030-00668-6_15)

[33] Ruben Verborgh and RubenVerborgh/N3.js contributors. 2023. N3.js: Lightning fast, spec-compliant, streaming RDF for JavaScript. <https://github.com/rdfjs/N3.js>. Accessed: 2025-04-24.

[34] Edward Yourdon and Larry Constantine. 1979. *Structured Design: Fundamentals of a Discipline of Computer Program and Systems Design*. Prentice Hall.

## A Further Implementation Details

### A.1 Actions as State

At the heart of the architecture is the idea that a system is composed of nothing more than data and agents. This means that in addition to data representing state, all actions associated with changes in state are fully reified as data as well. To provide maximum compatibility and to leverage existing tools, our implementation complies with Semantic Web [6] and Linked-Data [5] standards, and all data is represented in terms of RDF [7]. For example, the construction of a full action node representing a completion can uses the following JavaScript template:

```
`PREFIX : <${actionSchemaIRI}>
<${action}>
  :actions <${action}> ;
  :concept <${conceptIRI}> ;
  :name "${name}" ;
  :input ${input} ;
```

```
:output ${output} ;
:flow ${flow} .
```

This is formatted as Turtle (1.1) [4], where the \${} template parameters programmatically insert the corresponding bindings in code such as name for the action name and input for a string representation of all the input arguments (using blank node syntax for nesting).

In Turtle, triples ending with a period . represent an edge (property) between two nodes (a subject and object), while the semicolon ; is a shorthand for describing multiple properties of the same subject. This says that every instance of an action is associated with a concept, its name, and more data in the graph about its inputs and outputs, with the :flow parameter providing runtime provenance as described in Section 6.3.

### A.2 State and Information

Each concept is associated with its own *named graph*, a unique identifier for a logical grouping of data, which can both be versioned and shared to describe a particular instance for a given application. Every application and its full action history are then represented as another named graph, which can also be versioned and staged: by referencing <http://example.com/App/dev> as opposed to <http://example.com/App/stage>, eg, an entire execution environment can be separated cleanly at the storage level.

System state can be stored in any graph-based medium, which includes traditional relational/SQL databases and document stores in addition to dedicated graph databases, each with its own performance characteristics. For our implementation, we chose the N3.js [33] low-level library for an in-memory RDF compatible graph store, and the Comunica [32] SPARQL query engine to perform queries.

### A.3 Computational Agents

Concepts and synchronizations alike are represented uniformly in our implementation by *computational agents* (similar to actors [18], but simpler in that they cannot spawn other agents or pass messages to one another).

**A.3.1 Concept Agents.** A concept is implemented by a physical storage of graph-like data, and a computational agent responsible for implementing its behavior, which is described by a SPARQL query with this template:

```
`PREFIX : <${actionSchemaIRI}>
CONSTRUCT {
  ?_action :input ${input}
}
FROM <${actionGraphIRI}>
WHERE {
  ?_action
    :actions ?_action ;
    :concept <${conceptIRI}> ;
    :name "${name}" ;
    :input ${input} .
```

```
FILTER NOT EXISTS { ?_action :output [] }
}
```

The CONSTRUCT keyword specifies that the query should return the graph specified, which in this case includes any arbitrarily nested shape of nodes described by the `${input}` template parameter, and which is also fully specified in the action signature of the associated concept. This query says to simply find all actions that do not yet have an output and capture all the inputs for processing.

The behavior of a concept agent thus involves these steps:

1. Query the action graph (as above) for outstanding actions associated with the concept;
2. Perform each action and compute the state changes to insert into the concept state graph;
3. Insert the completion record with the output into the action graph.

The behavior of a concept agent might even be thought of as a kind of reverse synchronization that goes from invocation to completion, with `ACTION()` representing the arbitrary computational function of the agent:

```
when { Concept/action [ :input ?input ] }
where { bind ( ACTION(?input) as ?output ) }
then { Concept/action [ :input ?input ]
      => [ :output ?output ] }
```

**A.3.2 Synchronization Agents.** Synchronization agents function in a similar way: they look at outstanding action *completions* that have not yet been synchronized according to the specification, and insert *invocations* with the appropriately bound inputs. Their behavior can be characterized entirely by a transactional update query of the form:

```
...prefixes...
INSERT {
  ?_then_1
  :actions ?_then_1 ;
  ...properties... ;
  :flow ?_flow .
  ...thens...
  ?_when_1 :${syncName} ?_then_1 .
  ...synced...
}
WHERE {
  ...wheres...
  ?_when_1
  :actions ?_when_1 ;
  ...properties... ;
  :flow ?_flow .
  ...whens...
  FILTER NOT EXISTS { ?_when_1 :${syncName} [] }
  ...filters...
}
```

The triple dots `...thens...` indicate elided repetitions of (for example) other possible actions specified in the `then` clause. The shared `?_flow` token and `FILTER NOT EXISTS`

for the synchronization edge represent the implementations for these ideas described in Sections 6.3 and 6.6.

## B Concept Specification Examples

Each concept specification was generated using a system prompt that explained the overall pattern and the details of the specification language. The User concept specification below was given as an example.

### B.1 User: sample spec used in prompt

```
concept User [U]
purpose
  to associate identifying information with users
state
  users: set U
  name: U -> string
  email: U -> string
actions
  register [
    user: U ;
    name: string ;
    email: string ] => [ user: U ]
    associate user with users
    associate name and email unique + valid
    return the user reference
  register [
    user: U ;
    name: string ;
    email: string ] => [ error: string ]
    if either name/email is invalid or !unique
    return the error description
  update [ user: U ; name: string ] => [ user: U ]
    if name is unique, update user's name
    return the user reference
  update [ user: U ; name: string ]
    => [ error: string ]
    if name is not-unique, describe error
    return the error description
  update [ user: U ; email: string ]
    => [ user: U ]
    if email is unique + valid, update id's email
    return the user reference
  update [ user: U ; email: string ]
    => [ error: string ]
    if email is not-unique or invalid
    return the error description
operational principle
  after register [] => [ user: x ]
  and update [ name: "xavier" ] => [ user: x ]
  for any ?u such that ?u.name = "xavier", ?u = x
```

### B.2 Profile: a generated concept

The prompt for the Profile concept was:

*Create a concept for Profile, where the purpose is to associate descriptive information with an individual. A profile consists of a bio and an image (can be a string storing a URL).*

which generated the following specification:

```
concept Profile [P, U]
purpose
  to associate descriptive information with users
state
  profiles: set P
  profile: U -> P
  bio: P -> string
  image: P -> string
actions
  register [ profile: P ; user: U ]
    => [ profile: P ]
    add profile to profiles
    associate user with profile
    add a default blank bio and image to profile
    return profile
  update [ profile: P ; bio: string ]
    => [ profile: P ]
    update profile with bio
    return profile
  update [ profile: P ; image: string ]
    => [ profile: P ]
    if image is valid (URL, base64, etc.)
    update profile with image
    return profile
  update [ profile: P ; image: string ]
    => [ error: string ]
    if image is invalid, describe error
    return error
operational principle
  after register [ profile: p ; user: u ]
    => [ profile: p ]
  and update [ profile: p ; bio: "Hello world" ]
    => [ profile: p ]
  and update [ profile: p ; image: "pic.jpg" ]
    => [ profile: p ]
  the profile p contains both the updated bio
  "Hello world" and original image "pic.jpg"
```

## C Synchronization Generation

The general structure of a synchronization prompt included (1) a system prompt explaining the key ideas (an earlier version of Section 5), (2) the set of relevant concepts in only their specification form (no code), and (3) a user prompt describing the desired behavior. The following example shows how synchronizations were added to accommodate new concepts.

After generating the Article concept, this prompt was issued (along with copy-pasted RealWorld documentation for endpoint formats, to support the ad hoc response synchronization):

*Given the RealWorld specification, create a set of syncs for basic article management. You may propose a Tag concept and Favorite concept to help.*

The LLM responded with the Tag and Favorite concept specifications, which could then later have implementations generated. These concept specifications did not pose issues

and were generated in one-shot, and the generated implementations were sufficient for the purposes of synchronization with Article. In addition, the following is an excerpt of the synchronizations generated for article creation, along with a few demonstrations of error handling, authentication, and associating tags.

```
sync CreateArticle
when {
  Web/request: [
    method: "create_article" ;
    title: ?title ;
    description: ?description ;
    body: ?body ;
    token: ?token ]
    => [ request: ?request ] }
then {
  JWT/verify: [
    token: ?token ] }

sync HandleCreateArticleAuth
when {
  Web/request: [
    method: "create_article" ]
    => [ request: ?request ]
  JWT/verify: []
    => [ error: ?error ] }
then {
  Web/respond: [
    request: ?request ;
    error: ?error ;
    code: 401 ] }

sync PerformCreateArticle
when {
  Web/request: [
    method: "create_article" ;
    title: ?title ;
    description: ?description ;
    body: ?body ]
    => []
  JWT/verify: []
    => [ user: ?user ] }
where {
  BIND ( UUID() as ?article ) }
then {
  Article/create: [
    article: ?article ;
    title: ?title ;
    description: ?description ;
    body: ?body ;
    author: ?user ] }

sync HandleCreateArticleError
when {
  Web/request: [
    method: "create_article" ]
    => [ request: ?request ]
  Article/create: []
```

```

=> [ error: ?error ] }
then {
  Web/respond: [
    request: ?request ;
    error: ?error ;
    code: 422 ] }

sync CreateArticleFormat
when {
  Web/request: [
    method: "create_article" ]
    => [ request: ?request ]
  Article/create: []
    => [ article: ?article ]
  JWT/verify: []
    => [ user: ?currentUser ] }
then {
  Web/format: [
    type: "article_auth" ;
    article: ?article ;
    currentUser: ?currentUser ;
    request: ?request ] }

sync AddTagsToArticle
when {
  Web/request: [
    method: "create_article" ;
    tagList: ?tag ]
    => [ ]
  Article/create: []
    => [ slug: ?slug ] }
then {
  Tag/add: [ target: ?slug ; tag: ?tag ] }

```

### C.1 Response Formatting

The `Web/format` action called by the previous synchronizations factors out application-specific formatting details. In RealWorld, web responses are highly entangled, involving information from multiple concepts. The following example of a formatted article response shows how the language handles this complexity, leveraging SPARQL built-ins such as `OPTIONAL` graph joins for conditionally including information from other concepts.

As explained in Section 6.5, the `where` clause is a declarative query (akin to a SPARQL `SELECT`) whose result is a set of “frames” (each comprising a set of bindings of variables to values). This means that an article with multiple tags would result in a separate frame for each tag. To aggregate these by article, invoking the `then` clause once for each article and the associated values for other variables, we use a special variable `?_eachthen`. This mechanism functions identically to SPARQL’s `GROUP BY` for the purposes of specifying values to aggregate over (e.g. allowing grouping by composite keys), but circumvents the restriction that selections must be limited to aggregates and constants.

```

sync FormatArticle
when {
  Web/format: [
    type: "article" ;
    article: ?article ;
    request: ?request ]
    => [ ] }
where {
  Article: {
    ?article title: ?title ;
    description: ?description ;
    body: ?body ;
    slug: ?slug ;
    createdAt: ?createdAt ;
    updatedAt: ?updatedAt ;
    author: ?author }
  User: { ?author name: ?authorName }
  Profile: {
    ?author profile: ?profile .
    ?profile bio: ?authorBio ;
    image: ?authorImage }

  # Get tags for this article if they exist
  OPTIONAL {
    Tag: { ?article tag: ?tag } }

  # Get favorites count if it exists
  OPTIONAL {
    Favorite: { ?article count: ?count } }

  # Aggregate all results by unique article ID
  BIND ( ?article AS ?_eachthen ) }
then {
  Web/respond: [
    request: ?request ;
    body: [
      article: [
        slug: ?slug ;
        title: ?title ;
        description: ?description ;
        body: ?body ;
        tagList: ?tag ;
        createdAt: ?createdAt ;
        updatedAt: ?updatedAt ;
        favorited: false ;
        favoritesCount: ?count ;
        author: [
          username: ?authorName ;
          bio: ?authorBio ;
          image: ?authorImage ;
          following: false ] ] ] ] ]
  }

```

One final complication: if the article has no tag, the `tagList` field would not appear in the response object at all, but the RealWorld API would require a field with an empty list. To fix this, we can bind the field to a variable `?tagList` with:

```
BIND ( COALESCE( ?tag , rdf:nil ) AS ?tagList )
```